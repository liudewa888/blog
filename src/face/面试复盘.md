### 2023.06.13 之前总节

1. keep-alive 实现原理

- 组件切换时,保持组件状态
- include 字符串或正则,匹配会缓存;exclude 字符串和正则,匹配不会缓存;max 最多缓存组件实例数量
- 含有动态组件时,缓存不活动的组件实例
- 实现步骤
  1. 获取 keep-alive 下第一个子组件的实例对象,通过他去获取这个组件的组件名
  2. 通过组件名支匹配原来的 include 和 exclude,判断当前组件是否需要缓存,不需要缓存直接返回组件实例 VNode
  3. 需要缓存,是否在缓存数组里面: 存在,将原来位置上的 key 移除,将这个 key 放到数组最后面;不存在,组件 key 放入数组,判断当前 key 是数组是否超过 max 所设置的范围,超过,删除未使用一个组件 key
- 组件的 keepAlive 设置为 true

2. vue diff 算法
- 新旧两次虚拟dom的对比
- 是一个递归过程,同层比较,深度优先
    1. 判断两个节点是否为相同类节点,不同删除重新创建
    2. 双方都是文本则更新文本内容
    3. 都是元素节点则递归更新子元素
        - 数的子节点是文本,老的是数组,清空设置文本
        - 新的子节点是文本,老的是文本,更新文本
        - 新的子节点是数组,老的是文本,清空文本创建新子节点数组
        - 新老子节点都是数组,采用双指针进行比较
          1. 头头对比,头尾对比,最后还有剩余采用普通遍历
3. key 的作用
- 更高效的更新虚拟dom,在v-for中更好的`就近复用`
- patch过程判断两个节点是否是同一个节点key是必要条件,不定义key频繁更新元素,影响patch效率
- key必须是唯一的,不能使用数组索引
- vue判断两个节点是否相同判断key和元素类型,两个类型一样的元素不设置key,值就是undefined,就会认为是相同节点,执行更新操作
4. es6 常用

- promise
- 箭头函数
- async await
- 展开运算符, 解构赋值
- let 和 const
- set 和 map
- proxy
- symbol
- class 类
- es module

4. 事件循环

5. 原型链
- 实例对象中查找属性,没有,就去实例的原型查找,原型指向构造函数的prototype,也有原型指向它的原型对向,最后指向Object.prototye,还没找到Object.prototype._proto_指向null
6. 输入 url 发生什么

### 2023.06.13 非本人 面试

1. cdn 除了节点快还为什么快

- 缓存

2. vue diff 算法

3. loader 为什么是倒叙的
- 但只需知道从右到左的方式是叫 compose，而从左到右的方式就叫 pipe，这两种方式都是组合函数的方式。
- 不管是从左到右还是从右到左，都可以实现相同的功能。所以，Webpack 的 loader 的执行不管是从右到左还是从左到右，其实都可以实现，只不过 Webpack 选择了 compose 的方式来组合函数
4. babel transform runtime 和 profill 区别
